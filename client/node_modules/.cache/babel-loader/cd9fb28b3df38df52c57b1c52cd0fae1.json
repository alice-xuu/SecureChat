{"ast":null,"code":"/**\n * \n * @returns {CryptoKey} Symmetric Key\n */\nexport async function generateRSA() {\n  return await window.crypto.subtle.generateKey({\n    name: \"RSA-OAEP\",\n    modulusLength: 2048,\n    //can be 1024, 2048, or 4096\n    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n    hash: {\n      name: \"SHA-256\"\n    } //can be \"SHA-1\", \"SHA-256\", \"SHA-384\", or \"SHA-512\"\n\n  }, true, //whether the key is extractable (i.e. can be used in exportKey)\n  [\"encrypt\", \"decrypt\"]);\n}\n/**\n * \n * @returns {CryptoKey} Symmetric Key\n */\n\nexport async function generateRSASign() {\n  return await window.crypto.subtle.generateKey({\n    name: \"RSA-PSS\",\n    modulusLength: 2048,\n    //can be 1024, 2048, or 4096\n    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n    hash: {\n      name: \"SHA-256\"\n    } //can be \"SHA-1\", \"SHA-256\", \"SHA-384\", or \"SHA-512\"\n\n  }, true, //whether the key is extractable (i.e. can be used in exportKey)\n  [\"sign\", \"verify\"]);\n}\n/**\n * \n * @param {CryptoKey} key \n * @returns {object} key in jwk format\n */\n\nexport async function exportKey(key) {\n  return await window.crypto.subtle.exportKey(\"jwk\", key);\n}\n/**\n * \n * @returns {CryptoKey} Symmetric Key\n */\n\nexport async function generateAESKey() {\n  return await window.crypto.subtle.generateKey({\n    name: \"AES-GCM\",\n    length: 256\n  }, true, [\"encrypt\", \"decrypt\"]);\n}\n/**\n * \n * @param {string} key Stringified key in jwk format\n * @returns {CryptoKey}\n */\n\nexport async function importPublicKeySign(key) {\n  const jsonKey = JSON.parse(key);\n  return await window.crypto.subtle.importKey(\"jwk\", jsonKey, {\n    name: \"RSA-PSS\",\n    hash: {\n      name: \"SHA-256\"\n    }\n  }, true, [\"verify\"]);\n}\n/**\n * \n * @param {string} key Stringified key in jwk format\n * @returns {CryptoKey}\n */\n\nexport async function importPrivateKeySign(key) {\n  const jsonKey = JSON.parse(key);\n  return await window.crypto.subtle.importKey(\"jwk\", jsonKey, {\n    name: \"RSA-PSS\",\n    hash: {\n      name: \"SHA-256\"\n    }\n  }, true, [\"sign\"]);\n}\n/**\n * \n * @param {string} key Stringified key in jwk format\n * @returns {CryptoKey}\n */\n\nexport async function importPublicKey(key) {\n  const jsonKey = JSON.parse(key);\n  return await window.crypto.subtle.importKey(\"jwk\", jsonKey, {\n    name: \"RSA-OAEP\",\n    hash: {\n      name: \"SHA-256\"\n    }\n  }, true, [\"encrypt\"]);\n}\n/**\n * \n * @param {string} key Stringified key in jwk format\n * @returns {CryptoKey}\n */\n\nexport async function importPrivateKey(key) {\n  const jsonKey = JSON.parse(key);\n  return await window.crypto.subtle.importKey(\"jwk\", jsonKey, {\n    name: \"RSA-OAEP\",\n    hash: {\n      name: \"SHA-256\"\n    }\n  }, true, [\"decrypt\"]);\n}\n/**\n * \n * @param {string} key Stringified key in jwk format\n * @returns {CryptoKey}\n */\n\nexport async function importAESKey(key) {\n  const jsonKey = JSON.parse(key);\n  return await window.crypto.subtle.importKey(\"jwk\", jsonKey, \"AES-GCM\", true, [\"encrypt\", \"decrypt\"]);\n}\n/**\n * \n * @param {CryptoKey} publicKey \n * @param {string} msg \n * @returns {String}\n */\n\nexport async function encryptRSAMsg(publicKey, msg) {\n  let enc = new TextEncoder();\n  let encoded = enc.encode(msg);\n  let arrayBuffer = await window.crypto.subtle.encrypt({\n    name: \"RSA-OAEP\"\n  }, publicKey, encoded);\n  return arrayBufferToString(arrayBuffer);\n}\n/**\n * \n * @param {CryptoKey} key \n * @param {string} msg \n * @returns {ArrayBuffer}\n */\n\nexport async function encryptAESMsg(key, msg) {\n  let enc = new TextEncoder();\n  let encoded = enc.encode(msg);\n  let iv = window.crypto.getRandomValues(new Uint8Array(12));\n  return await window.crypto.subtle.encrypt({\n    name: \"AES-GCM\",\n    iv\n  }, key, encoded);\n}\nexport class EncryptedMessage {\n  /**\n   * @param {string} message JSON stringified object with form \"{ message: \"\", iv: \"\"}\"\n   */\n  constructor(message) {\n    let obj = JSON.parse(message);\n    this.message = obj.message;\n    this.iv = obj.iv;\n  }\n  /**\n   * @param {CryptoKey} key \n   * @returns {String} decrypted message\n   */\n\n\n  async decrypt(key) {\n    if (key.usages.indexOf('decrypt') < 0) throw new Error('Key not valid for message type');\n    let algorithm = key.algorithm.name;\n    let decoder = new TextDecoder(\"utf-8\");\n\n    if (algorithm === \"AES-GCM\") {\n      let decrypted = await window.crypto.subtle.decrypt({\n        name: algorithm,\n        iv: stringToArrayBuffer(this.iv)\n      }, key, stringToArrayBuffer(this.message));\n      return decoder.decode(decrypted);\n    } else {\n      let decrypted = await window.crypto.subtle.decrypt({\n        name: algorithm\n      }, key, stringToArrayBuffer(this.message));\n      return decoder.decode(decrypted);\n    }\n  }\n\n  toString() {\n    return JSON.stringify({\n      message: this.message,\n      iv: this.iv\n    });\n  }\n\n}\nexport class PlaintextMessage {\n  /**\n   * @param {string} message \n   */\n  constructor(message) {\n    this.message = message;\n  }\n  /**\n   * @param {CryptoKey} key\n   * @returns {string} Stringified JSON in format {\"message\":\"\", \"iv\":\"\"}\n   */\n\n\n  async encrypt(key) {\n    if (key.usages.indexOf('encrypt') < 0) throw new Error('Key not valid for message type');\n    let algorithm = key.algorithm.name;\n    const encoder = new TextEncoder();\n    const encodedMsg = encoder.encode(this.message);\n\n    if (algorithm === \"AES-GCM\") {\n      let iv = window.crypto.getRandomValues(new Uint8Array(12));\n      let encMessage = await window.crypto.subtle.encrypt({\n        name: algorithm,\n        iv\n      }, key, encodedMsg);\n      return JSON.stringify({\n        message: arrayBufferToString(encMessage),\n        iv: arrayBufferToString(iv)\n      });\n    } else {\n      let encMessage = await window.crypto.subtle.encrypt({\n        name: algorithm\n      }, key, encodedMsg);\n      return JSON.stringify({\n        message: arrayBufferToString(encMessage)\n      });\n    }\n  }\n\n  toString() {\n    return this.message;\n  }\n\n}\n/**\n * \n * @param {ArrayBuffer} buffer \n * @returns {String} \n */\n\nfunction arrayBufferToString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n\n  for (var i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n\n  var base64 = window.btoa(binary); // convert unicode string to string where each 16-bit unit occupies one byte\n\n  const codeUnits = new Uint16Array(base64.length);\n\n  for (let i = 0; i < codeUnits.length; i++) {\n    codeUnits[i] = base64.charCodeAt(i);\n  }\n\n  return btoa(String.fromCharCode(...new Uint8Array(codeUnits.buffer)));\n}\n/**\n * \n * @param {String} string \n * @returns {ArrayBuffer}\n */\n\n\nfunction stringToArrayBuffer(string) {\n  const binary = atob(string);\n  const bytes = new Uint8Array(binary.length);\n\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n\n  var base64 = String.fromCharCode(...new Uint16Array(bytes.buffer));\n  var binStr = window.atob(base64);\n  var bytes2 = new Uint8Array(binStr.length);\n\n  for (var i = 0; i < binStr.length; i++) {\n    bytes2[i] = binStr.charCodeAt(i);\n  }\n\n  return bytes2.buffer;\n}","map":{"version":3,"sources":["/Users/AliceXu/Desktop/uni/Y4 Semester 1/INFO2222/INFO2222-Assignment-1-main/client/src/encryption.js"],"names":["generateRSA","window","crypto","subtle","generateKey","name","modulusLength","publicExponent","Uint8Array","hash","generateRSASign","exportKey","key","generateAESKey","length","importPublicKeySign","jsonKey","JSON","parse","importKey","importPrivateKeySign","importPublicKey","importPrivateKey","importAESKey","encryptRSAMsg","publicKey","msg","enc","TextEncoder","encoded","encode","arrayBuffer","encrypt","arrayBufferToString","encryptAESMsg","iv","getRandomValues","EncryptedMessage","constructor","message","obj","decrypt","usages","indexOf","Error","algorithm","decoder","TextDecoder","decrypted","stringToArrayBuffer","decode","toString","stringify","PlaintextMessage","encoder","encodedMsg","encMessage","buffer","binary","bytes","i","byteLength","String","fromCharCode","base64","btoa","codeUnits","Uint16Array","charCodeAt","string","atob","binStr","bytes2"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,eAAeA,WAAf,GAA4B;AAC/B,SAAO,MAAMC,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBC,WAArB,CAAiC;AAC1CC,IAAAA,IAAI,EAAE,UADoC;AAE1CC,IAAAA,aAAa,EAAE,IAF2B;AAErB;AACrBC,IAAAA,cAAc,EAAE,IAAIC,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAAf,CAH0B;AAI1CC,IAAAA,IAAI,EAAE;AAACJ,MAAAA,IAAI,EAAE;AAAP,KAJoC,CAIjB;;AAJiB,GAAjC,EAMb,IANa,EAMP;AACN,GAAC,SAAD,EAAY,SAAZ,CAPa,CAAb;AAQH;AAED;AACA;AACA;AACA;;AACA,OAAO,eAAeK,eAAf,GAAgC;AACnC,SAAO,MAAMT,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBC,WAArB,CACT;AACIC,IAAAA,IAAI,EAAE,SADV;AAEIC,IAAAA,aAAa,EAAE,IAFnB;AAEyB;AACrBC,IAAAA,cAAc,EAAE,IAAIC,UAAJ,CAAe,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAAf,CAHpB;AAIIC,IAAAA,IAAI,EAAE;AAACJ,MAAAA,IAAI,EAAE;AAAP,KAJV,CAI6B;;AAJ7B,GADS,EAOT,IAPS,EAOH;AACN,GAAC,MAAD,EAAS,QAAT,CARS,CAAb;AAUH;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAeM,SAAf,CAAyBC,GAAzB,EAA6B;AAChC,SAAO,MAAMX,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBQ,SAArB,CAA+B,KAA/B,EAAsCC,GAAtC,CAAb;AACH;AAED;AACA;AACA;AACA;;AACA,OAAO,eAAeC,cAAf,GAA+B;AAClC,SAAO,MAAMZ,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBC,WAArB,CACT;AACIC,IAAAA,IAAI,EAAE,SADV;AAEIS,IAAAA,MAAM,EAAE;AAFZ,GADS,EAKT,IALS,EAMT,CAAC,SAAD,EAAY,SAAZ,CANS,CAAb;AAQH;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAeC,mBAAf,CAAmCH,GAAnC,EAAuC;AAC1C,QAAMI,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWN,GAAX,CAAhB;AACA,SAAO,MAAMX,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBgB,SAArB,CACT,KADS,EAETH,OAFS,EAGT;AACIX,IAAAA,IAAI,EAAE,SADV;AAEII,IAAAA,IAAI,EAAC;AAACJ,MAAAA,IAAI,EAAC;AAAN;AAFT,GAHS,EAOT,IAPS,EAQT,CAAC,QAAD,CARS,CAAb;AAUH;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAee,oBAAf,CAAoCR,GAApC,EAAwC;AAC3C,QAAMI,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWN,GAAX,CAAhB;AACA,SAAO,MAAMX,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBgB,SAArB,CAET,KAFS,EAGTH,OAHS,EAIT;AACIX,IAAAA,IAAI,EAAE,SADV;AAEII,IAAAA,IAAI,EAAC;AAACJ,MAAAA,IAAI,EAAC;AAAN;AAFT,GAJS,EAQT,IARS,EAST,CAAC,MAAD,CATS,CAAb;AAWH;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAegB,eAAf,CAA+BT,GAA/B,EAAmC;AACtC,QAAMI,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWN,GAAX,CAAhB;AACA,SAAO,MAAMX,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBgB,SAArB,CACT,KADS,EAETH,OAFS,EAGT;AACIX,IAAAA,IAAI,EAAE,UADV;AAEII,IAAAA,IAAI,EAAC;AAACJ,MAAAA,IAAI,EAAC;AAAN;AAFT,GAHS,EAOT,IAPS,EAQT,CAAC,SAAD,CARS,CAAb;AAUH;AAED;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAeiB,gBAAf,CAAgCV,GAAhC,EAAoC;AACvC,QAAMI,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWN,GAAX,CAAhB;AACA,SAAO,MAAMX,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBgB,SAArB,CAET,KAFS,EAGTH,OAHS,EAIT;AACIX,IAAAA,IAAI,EAAE,UADV;AAEII,IAAAA,IAAI,EAAC;AAACJ,MAAAA,IAAI,EAAC;AAAN;AAFT,GAJS,EAQT,IARS,EAST,CAAC,SAAD,CATS,CAAb;AAWH;AAED;AACA;AACA;AACA;AACA;;AACC,OAAO,eAAekB,YAAf,CAA4BX,GAA5B,EAAgC;AACpC,QAAMI,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWN,GAAX,CAAhB;AACA,SAAO,MAAMX,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBgB,SAArB,CACT,KADS,EAETH,OAFS,EAGT,SAHS,EAIT,IAJS,EAKT,CAAC,SAAD,EAAY,SAAZ,CALS,CAAb;AAOH;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAeQ,aAAf,CAA6BC,SAA7B,EAAwCC,GAAxC,EAA4C;AAC/C,MAAIC,GAAG,GAAG,IAAIC,WAAJ,EAAV;AACA,MAAIC,OAAO,GAAGF,GAAG,CAACG,MAAJ,CAAWJ,GAAX,CAAd;AACA,MAAIK,WAAW,GAAG,MAAM9B,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqB6B,OAArB,CACpB;AACI3B,IAAAA,IAAI,EAAE;AADV,GADoB,EAIpBoB,SAJoB,EAKpBI,OALoB,CAAxB;AAOA,SAAOI,mBAAmB,CAACF,WAAD,CAA1B;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;AACC,OAAO,eAAeG,aAAf,CAA6BtB,GAA7B,EAAkCc,GAAlC,EAAsC;AAC1C,MAAIC,GAAG,GAAG,IAAIC,WAAJ,EAAV;AACA,MAAIC,OAAO,GAAGF,GAAG,CAACG,MAAJ,CAAWJ,GAAX,CAAd;AACA,MAAIS,EAAE,GAAGlC,MAAM,CAACC,MAAP,CAAckC,eAAd,CAA8B,IAAI5B,UAAJ,CAAe,EAAf,CAA9B,CAAT;AACA,SAAO,MAAMP,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqB6B,OAArB,CACT;AACI3B,IAAAA,IAAI,EAAE,SADV;AAEI8B,IAAAA;AAFJ,GADS,EAKTvB,GALS,EAMTiB,OANS,CAAb;AAQH;AAED,OAAO,MAAMQ,gBAAN,CAAuB;AAC1B;AACJ;AACA;AACIC,EAAAA,WAAW,CAACC,OAAD,EAAS;AAChB,QAAIC,GAAG,GAAGvB,IAAI,CAACC,KAAL,CAAWqB,OAAX,CAAV;AACA,SAAKA,OAAL,GAAeC,GAAG,CAACD,OAAnB;AACA,SAAKJ,EAAL,GAAUK,GAAG,CAACL,EAAd;AACH;AAED;AACJ;AACA;AACA;;;AACiB,QAAPM,OAAO,CAAC7B,GAAD,EAAK;AACd,QAAGA,GAAG,CAAC8B,MAAJ,CAAWC,OAAX,CAAmB,SAAnB,IAAgC,CAAnC,EACI,MAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;AACJ,QAAIC,SAAS,GAAGjC,GAAG,CAACiC,SAAJ,CAAcxC,IAA9B;AACA,QAAIyC,OAAO,GAAG,IAAIC,WAAJ,CAAgB,OAAhB,CAAd;;AACA,QAAGF,SAAS,KAAK,SAAjB,EAA2B;AACvB,UAAIG,SAAS,GAAG,MAAM/C,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBsC,OAArB,CAA6B;AAC/CpC,QAAAA,IAAI,EAAEwC,SADyC;AAE/CV,QAAAA,EAAE,EAAEc,mBAAmB,CAAC,KAAKd,EAAN;AAFwB,OAA7B,EAGnBvB,GAHmB,EAGdqC,mBAAmB,CAAC,KAAKV,OAAN,CAHL,CAAtB;AAIA,aAAOO,OAAO,CAACI,MAAR,CAAeF,SAAf,CAAP;AACH,KAND,MAOI;AACA,UAAIA,SAAS,GAAG,MAAM/C,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqBsC,OAArB,CAA6B;AAC/CpC,QAAAA,IAAI,EAAEwC;AADyC,OAA7B,EAEnBjC,GAFmB,EAEdqC,mBAAmB,CAAC,KAAKV,OAAN,CAFL,CAAtB;AAGA,aAAOO,OAAO,CAACI,MAAR,CAAeF,SAAf,CAAP;AACH;AACJ;;AAEDG,EAAAA,QAAQ,GAAE;AACN,WAAOlC,IAAI,CAACmC,SAAL,CAAe;AAACb,MAAAA,OAAO,EAAE,KAAKA,OAAf;AAAwBJ,MAAAA,EAAE,EAAE,KAAKA;AAAjC,KAAf,CAAP;AACH;;AApCyB;AAuC9B,OAAO,MAAMkB,gBAAN,CAAuB;AAC1B;AACJ;AACA;AACIf,EAAAA,WAAW,CAACC,OAAD,EAAS;AAChB,SAAKA,OAAL,GAAeA,OAAf;AACH;AAED;AACJ;AACA;AACA;;;AACiB,QAAPP,OAAO,CAACpB,GAAD,EAAK;AACd,QAAGA,GAAG,CAAC8B,MAAJ,CAAWC,OAAX,CAAmB,SAAnB,IAAgC,CAAnC,EACI,MAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;AACJ,QAAIC,SAAS,GAAGjC,GAAG,CAACiC,SAAJ,CAAcxC,IAA9B;AACA,UAAMiD,OAAO,GAAG,IAAI1B,WAAJ,EAAhB;AACA,UAAM2B,UAAU,GAAGD,OAAO,CAACxB,MAAR,CAAe,KAAKS,OAApB,CAAnB;;AACA,QAAGM,SAAS,KAAK,SAAjB,EAA2B;AACvB,UAAIV,EAAE,GAAGlC,MAAM,CAACC,MAAP,CAAckC,eAAd,CAA8B,IAAI5B,UAAJ,CAAe,EAAf,CAA9B,CAAT;AACA,UAAIgD,UAAU,GAAG,MAAMvD,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqB6B,OAArB,CAA6B;AAChD3B,QAAAA,IAAI,EAAEwC,SAD0C;AAEhDV,QAAAA;AAFgD,OAA7B,EAGpBvB,GAHoB,EAGf2C,UAHe,CAAvB;AAIA,aAAOtC,IAAI,CAACmC,SAAL,CAAe;AAACb,QAAAA,OAAO,EAAEN,mBAAmB,CAACuB,UAAD,CAA7B;AAA2CrB,QAAAA,EAAE,EAAEF,mBAAmB,CAACE,EAAD;AAAlE,OAAf,CAAP;AACH,KAPD,MAQI;AACA,UAAIqB,UAAU,GAAG,MAAMvD,MAAM,CAACC,MAAP,CAAcC,MAAd,CAAqB6B,OAArB,CAA6B;AAChD3B,QAAAA,IAAI,EAAEwC;AAD0C,OAA7B,EAEpBjC,GAFoB,EAEf2C,UAFe,CAAvB;AAGA,aAAOtC,IAAI,CAACmC,SAAL,CAAe;AAACb,QAAAA,OAAO,EAAEN,mBAAmB,CAACuB,UAAD;AAA7B,OAAf,CAAP;AACH;AACJ;;AAEDL,EAAAA,QAAQ,GAAE;AACN,WAAO,KAAKZ,OAAZ;AACH;;AApCyB;AAuC9B;AACA;AACA;AACA;AACA;;AACA,SAASN,mBAAT,CAA8BwB,MAA9B,EAAuC;AACnC,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,KAAK,GAAG,IAAInD,UAAJ,CAAgBiD,MAAhB,CAAZ;;AACA,OAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,UAA1B,EAAsCD,CAAC,EAAvC,EAA2C;AACvCF,IAAAA,MAAM,IAAII,MAAM,CAACC,YAAP,CAAqBJ,KAAK,CAAEC,CAAF,CAA1B,CAAV;AACH;;AACD,MAAII,MAAM,GAAG/D,MAAM,CAACgE,IAAP,CAAaP,MAAb,CAAb,CANmC,CAOnC;;AACA,QAAMQ,SAAS,GAAG,IAAIC,WAAJ,CAAgBH,MAAM,CAAClD,MAAvB,CAAlB;;AACA,OAAK,IAAI8C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,SAAS,CAACpD,MAA9B,EAAsC8C,CAAC,EAAvC,EAA2C;AACvCM,IAAAA,SAAS,CAACN,CAAD,CAAT,GAAeI,MAAM,CAACI,UAAP,CAAkBR,CAAlB,CAAf;AACH;;AACD,SAAOK,IAAI,CAACH,MAAM,CAACC,YAAP,CAAoB,GAAG,IAAIvD,UAAJ,CAAe0D,SAAS,CAACT,MAAzB,CAAvB,CAAD,CAAX;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASR,mBAAT,CAA6BoB,MAA7B,EAAqC;AAEjC,QAAMX,MAAM,GAAGY,IAAI,CAACD,MAAD,CAAnB;AACA,QAAMV,KAAK,GAAG,IAAInD,UAAJ,CAAekD,MAAM,CAAC5C,MAAtB,CAAd;;AACA,OAAK,IAAI8C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAAC7C,MAA1B,EAAkC8C,CAAC,EAAnC,EAAuC;AACnCD,IAAAA,KAAK,CAACC,CAAD,CAAL,GAAWF,MAAM,CAACU,UAAP,CAAkBR,CAAlB,CAAX;AACH;;AACD,MAAII,MAAM,GAAGF,MAAM,CAACC,YAAP,CAAoB,GAAG,IAAII,WAAJ,CAAgBR,KAAK,CAACF,MAAtB,CAAvB,CAAb;AAEA,MAAIc,MAAM,GAAItE,MAAM,CAACqE,IAAP,CAAYN,MAAZ,CAAd;AACA,MAAIQ,MAAM,GAAG,IAAIhE,UAAJ,CAAe+D,MAAM,CAACzD,MAAtB,CAAb;;AACA,OAAK,IAAI8C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGW,MAAM,CAACzD,MAA3B,EAAmC8C,CAAC,EAApC,EAA+C;AAC3CY,IAAAA,MAAM,CAACZ,CAAD,CAAN,GAAYW,MAAM,CAACH,UAAP,CAAkBR,CAAlB,CAAZ;AACH;;AACD,SAAOY,MAAM,CAACf,MAAd;AACH","sourcesContent":["/**\n * \n * @returns {CryptoKey} Symmetric Key\n */\nexport async function generateRSA(){\n    return await window.crypto.subtle.generateKey({\n        name: \"RSA-OAEP\",\n        modulusLength: 2048, //can be 1024, 2048, or 4096\n        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        hash: {name: \"SHA-256\"}, //can be \"SHA-1\", \"SHA-256\", \"SHA-384\", or \"SHA-512\"\n    },\n    true, //whether the key is extractable (i.e. can be used in exportKey)\n    [\"encrypt\", \"decrypt\"]);\n}\n\n/**\n * \n * @returns {CryptoKey} Symmetric Key\n */\nexport async function generateRSASign(){\n    return await window.crypto.subtle.generateKey(\n        {\n            name: \"RSA-PSS\",\n            modulusLength: 2048, //can be 1024, 2048, or 4096\n            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n            hash: {name: \"SHA-256\"}, //can be \"SHA-1\", \"SHA-256\", \"SHA-384\", or \"SHA-512\"\n        },\n        true, //whether the key is extractable (i.e. can be used in exportKey)\n        [\"sign\", \"verify\"]\n    )\n}\n\n/**\n * \n * @param {CryptoKey} key \n * @returns {object} key in jwk format\n */\nexport async function exportKey(key){\n    return await window.crypto.subtle.exportKey(\"jwk\", key);\n}\n\n/**\n * \n * @returns {CryptoKey} Symmetric Key\n */\nexport async function generateAESKey(){\n    return await window.crypto.subtle.generateKey(\n        {\n            name: \"AES-GCM\",\n            length: 256\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    );\n}\n\n/**\n * \n * @param {string} key Stringified key in jwk format\n * @returns {CryptoKey}\n */\nexport async function importPublicKeySign(key){\n    const jsonKey = JSON.parse(key)\n    return await window.crypto.subtle.importKey(\n        \"jwk\",\n        jsonKey,\n        {\n            name: \"RSA-PSS\",\n            hash:{name:\"SHA-256\"},\n        },\n        true,\n        [\"verify\"]\n    );\n}\n\n/**\n * \n * @param {string} key Stringified key in jwk format\n * @returns {CryptoKey}\n */\nexport async function importPrivateKeySign(key){\n    const jsonKey = JSON.parse(key)\n    return await window.crypto.subtle.importKey(\n\n        \"jwk\",\n        jsonKey,\n        {\n            name: \"RSA-PSS\",\n            hash:{name:\"SHA-256\"},\n        },\n        true,\n        [\"sign\"]\n    );\n}\n\n/**\n * \n * @param {string} key Stringified key in jwk format\n * @returns {CryptoKey}\n */\nexport async function importPublicKey(key){\n    const jsonKey = JSON.parse(key)\n    return await window.crypto.subtle.importKey(\n        \"jwk\",\n        jsonKey,\n        {\n            name: \"RSA-OAEP\",\n            hash:{name:\"SHA-256\"},\n        },\n        true,\n        [\"encrypt\"]\n    );\n}\n\n/**\n * \n * @param {string} key Stringified key in jwk format\n * @returns {CryptoKey}\n */\nexport async function importPrivateKey(key){\n    const jsonKey = JSON.parse(key)\n    return await window.crypto.subtle.importKey(\n\n        \"jwk\",\n        jsonKey,\n        {\n            name: \"RSA-OAEP\",\n            hash:{name:\"SHA-256\"},\n        },\n        true,\n        [\"decrypt\"]\n    );\n}\n\n/**\n * \n * @param {string} key Stringified key in jwk format\n * @returns {CryptoKey}\n */\n export async function importAESKey(key){\n    const jsonKey = JSON.parse(key)\n    return await window.crypto.subtle.importKey(\n        \"jwk\",\n        jsonKey,\n        \"AES-GCM\",\n        true,\n        [\"encrypt\", \"decrypt\"]\n    );\n}\n\n/**\n * \n * @param {CryptoKey} publicKey \n * @param {string} msg \n * @returns {String}\n */\nexport async function encryptRSAMsg(publicKey, msg){\n    let enc = new TextEncoder();\n    let encoded = enc.encode(msg)\n    let arrayBuffer = await window.crypto.subtle.encrypt(\n        {\n            name: \"RSA-OAEP\"\n        },\n        publicKey,\n        encoded\n    );\n    return arrayBufferToString(arrayBuffer);\n}\n\n/**\n * \n * @param {CryptoKey} key \n * @param {string} msg \n * @returns {ArrayBuffer}\n */\n export async function encryptAESMsg(key, msg){\n    let enc = new TextEncoder();\n    let encoded = enc.encode(msg);\n    let iv = window.crypto.getRandomValues(new Uint8Array(12));\n    return await window.crypto.subtle.encrypt(\n        {\n            name: \"AES-GCM\",\n            iv\n        },\n        key,\n        encoded\n    );\n}\n\nexport class EncryptedMessage {\n    /**\n     * @param {string} message JSON stringified object with form \"{ message: \"\", iv: \"\"}\"\n     */\n    constructor(message){\n        let obj = JSON.parse(message);\n        this.message = obj.message;\n        this.iv = obj.iv;\n    }\n\n    /**\n     * @param {CryptoKey} key \n     * @returns {String} decrypted message\n     */\n    async decrypt(key){\n        if(key.usages.indexOf('decrypt') < 0)\n            throw new Error('Key not valid for message type');\n        let algorithm = key.algorithm.name;\n        let decoder = new TextDecoder(\"utf-8\");\n        if(algorithm === \"AES-GCM\"){\n            let decrypted = await window.crypto.subtle.decrypt({\n                name: algorithm,\n                iv: stringToArrayBuffer(this.iv)\n            }, key, stringToArrayBuffer(this.message));\n            return decoder.decode(decrypted);\n        }\n        else{\n            let decrypted = await window.crypto.subtle.decrypt({\n                name: algorithm\n            }, key, stringToArrayBuffer(this.message));\n            return decoder.decode(decrypted);\n        }\n    }\n\n    toString(){\n        return JSON.stringify({message: this.message, iv: this.iv});\n    }\n}\n\nexport class PlaintextMessage {\n    /**\n     * @param {string} message \n     */\n    constructor(message){\n        this.message = message;\n    }\n\n    /**\n     * @param {CryptoKey} key\n     * @returns {string} Stringified JSON in format {\"message\":\"\", \"iv\":\"\"}\n     */\n    async encrypt(key){\n        if(key.usages.indexOf('encrypt') < 0)\n            throw new Error('Key not valid for message type');\n        let algorithm = key.algorithm.name;\n        const encoder = new TextEncoder();\n        const encodedMsg = encoder.encode(this.message);\n        if(algorithm === \"AES-GCM\"){\n            let iv = window.crypto.getRandomValues(new Uint8Array(12));\n            let encMessage = await window.crypto.subtle.encrypt({\n                name: algorithm,\n                iv\n            }, key, encodedMsg);\n            return JSON.stringify({message: arrayBufferToString(encMessage), iv: arrayBufferToString(iv)});\n        }\n        else{\n            let encMessage = await window.crypto.subtle.encrypt({\n                name: algorithm\n            }, key, encodedMsg);\n            return JSON.stringify({message: arrayBufferToString(encMessage)});\n        }\n    }\n\n    toString(){\n        return this.message;\n    }\n}\n\n/**\n * \n * @param {ArrayBuffer} buffer \n * @returns {String} \n */\nfunction arrayBufferToString( buffer ) {\n    var binary = '';\n    var bytes = new Uint8Array( buffer );\n    for (var i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode( bytes[ i ] );\n    }\n    var base64 = window.btoa( binary );\n    // convert unicode string to string where each 16-bit unit occupies one byte\n    const codeUnits = new Uint16Array(base64.length);\n    for (let i = 0; i < codeUnits.length; i++) {\n        codeUnits[i] = base64.charCodeAt(i);\n    }\n    return btoa(String.fromCharCode(...new Uint8Array(codeUnits.buffer)));\n}\n\n/**\n * \n * @param {String} string \n * @returns {ArrayBuffer}\n */\nfunction stringToArrayBuffer(string) {\n\n    const binary = atob(string);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    var base64 = String.fromCharCode(...new Uint16Array(bytes.buffer));\n\n    var binStr =  window.atob(base64);\n    var bytes2 = new Uint8Array(binStr.length);\n    for (var i = 0; i < binStr.length; i++)        {\n        bytes2[i] = binStr.charCodeAt(i);\n    }\n    return bytes2.buffer;\n}"]},"metadata":{},"sourceType":"module"}